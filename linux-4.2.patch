diff -ur xorg-driver-video-fglrx-15.9.orig/common/lib/modules/fglrx/build_mod/firegl_public.c xorg-driver-video-fglrx-15.9/common/lib/modules/fglrx/build_mod/firegl_public.c
--- xorg-driver-video-fglrx-15.9.orig/common/lib/modules/fglrx/build_mod/firegl_public.c	2015-09-27 20:53:27.340395813 +0200
+++ xorg-driver-video-fglrx-15.9/common/lib/modules/fglrx/build_mod/firegl_public.c	2015-09-27 20:54:13.834346677 +0200
@@ -188,10 +188,18 @@
 #include <linux/string.h>
 #include <linux/gfp.h>
 #include <linux/swap.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+#include <asm/fpu/api.h>
+#else
 #include "asm/i387.h"
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+#include <asm/fpu/internal.h>
+#else
 #include <asm/fpu-internal.h>
 #endif
+#endif
 
 #include "firegl_public.h"
 #include "kcl_osconfig.h"
@@ -620,8 +628,13 @@
 
     len = snprintf(buf, request, "%d\n", major);
 #else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,3,0)
+    seq_printf(m, "%d\n", major);
+    len = 0;
+#else
     len = seq_printf(m, "%d\n", major);
 #endif
+#endif
 
     KCL_DEBUG1(FN_FIREGL_PROC, "return len=%i\n",len);
 
@@ -1703,6 +1716,9 @@
 
 #if defined(__i386__) 
 #ifndef __HAVE_ARCH_CMPXCHG
+#ifndef __xg
+#define __xg(x) ((volatile long *)(x))
+#endif
 static inline 
 unsigned long __fgl_cmpxchg(volatile void *ptr, unsigned long old,            
                         unsigned long new, int size)                      
@@ -1739,7 +1755,11 @@
          unsigned long new, int size)
 {
 #ifndef __HAVE_ARCH_CMPXCHG
-    return __fgl_cmpxchg(ptr,old,new,size);
+#if defined(__i386__)
+     return __fgl_cmpxchg(ptr,old,new,size);
+#elif defined(__x86_64__)
+    return cmpxchg((unsigned long*)ptr,old,new);
+#endif
 #else
     /* On kernel version 2.6.34 passing a variable or unsupported size
      * argument to the __cmpxchg macro causes the default-clause of a
@@ -6422,6 +6442,48 @@
     return i;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+/*
+ * Save processor xstate to xsave area.
+ */
+static void _copy_xregs_to_kernel(struct xregs_state *xstate)
+{
+        u64 mask = -1;
+        u32 lmask = mask;
+        u32 hmask = mask >> 32;
+        int err = 0;
+
+        /*WARN_ON(!alternatives_patched);*/
+
+        /*
+         * If xsaves is enabled, xsaves replaces xsaveopt because
+         * it supports compact format and supervisor states in addition to
+         * modified optimization in xsaveopt.
+         *
+         * Otherwise, if xsaveopt is enabled, xsaveopt replaces xsave
+         * because xsaveopt supports modified optimization which is not
+         * supported by xsave.
+         *
+         * If none of xsaves and xsaveopt is enabled, use xsave.
+         */
+        alternative_input_2(
+                "1:"XSAVE,
+                XSAVEOPT,
+                X86_FEATURE_XSAVEOPT,
+                XSAVES,
+                X86_FEATURE_XSAVES,
+                [xstate] "D" (xstate), "a" (lmask), "d" (hmask) :
+                "memory");
+        asm volatile("2:\n\t"
+                     xstate_fault(err)
+                     : "0" (err)
+                     : "memory");
+
+        /* We should never fault when copying to a kernel buffer: */
+        WARN_ON_FPU(err);
+}
+#endif
+
 /** \brief Generate UUID
  *  \param buf pointer to the generated UUID
  *  \return None
@@ -6437,21 +6499,36 @@
    struct fpu *fpu = &tsk->thread.fpu;
 
    if(static_cpu_has(X86_FEATURE_XSAVE)) {
-      fpu_xsave(fpu);
-      if (!(fpu->state->xsave.xsave_hdr.xstate_bv & XSTATE_FP))
-	 return 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+       fpu_xsave(fpu);
+       if (!(fpu->state->xsave.xsave_hdr.xstate_bv & XSTATE_FP))
+#else
+      _copy_xregs_to_kernel(&fpu->state.xsave);
+      if (!(fpu->state.xsave.header.xfeatures & XSTATE_FP))
+#endif
+	return 1;
    } else if (static_cpu_has(X86_FEATURE_FXSR)) {
-	 fpu_fxsave(fpu);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+         fpu_fxsave(fpu);
+#else
+     copy_fxregs_to_kernel(fpu);
+#endif
    } else {
-	 asm volatile("fnsave %[fx]; fwait"
+	asm volatile("fnsave %[fx]; fwait"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
                   : [fx] "=m" (fpu->state->fsave));
-	 return 0;
+#else
+                  : [fx] "=m" (fpu->state.fsave));
+#endif
+	return 0;
    }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
    if (unlikely(fpu->state->fxsave.swd & X87_FSW_ES)) {
 	asm volatile("fnclex");
 	return 0;
    }
+#endif
    return 1;
 }
 #endif
@@ -6463,7 +6540,11 @@
 void ATI_API_CALL KCL_fpu_begin(void)
 {
 #ifdef CONFIG_X86_64
-    kernel_fpu_begin();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+     kernel_fpu_begin();
+#else
+    __kernel_fpu_begin();
+#endif
 #else
 #ifdef TS_USEDFPU
     struct thread_info *cur_thread = current_thread_info();
@@ -6473,8 +6554,12 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
          KCL_fpu_save_init(cur_task);
 #else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+         copy_fpregs_to_fpstate(&cur_task->thread.fpu);
+#else
          __save_init_fpu(cur_task);
 #endif
+#endif
     else
          clts();
 
@@ -6488,15 +6573,24 @@
     /* The thread structure is changed with the commit below for kernel 3.3:
      * https://github.com/torvalds/linux/commit/7e16838d94b566a17b65231073d179bc04d590c8
      */
-    if (cur_task->thread.fpu.has_fpu)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+	if (cur_task->thread.fpu.fpregs_active)
+#else
+	if (cur_task->thread.fpu.has_fpu)
+#endif
+
 #else
     if (cur_task->thread.has_fpu)
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
         KCL_fpu_save_init(cur_task);
 #else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+        copy_fpregs_to_fpstate(&cur_task->thread.fpu);
+#else
         __save_init_fpu(cur_task);
 #endif
+#endif
     else
          clts();
 #endif
@@ -6509,7 +6603,11 @@
  */
 void ATI_API_CALL KCL_fpu_end(void)
 {
-    kernel_fpu_end();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+     kernel_fpu_end();
+#else
+    __kernel_fpu_end();
+#endif
 }
 
 /** Create new directory entry under "/proc/...."
